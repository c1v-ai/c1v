---
phase: 09-data-model-depth
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/langchain/agents/tech-stack-agent.ts
  - lib/db/queries/project-data.ts
autonomous: true

must_haves:
  truths:
    - "techStack column exists in project_data table"
    - "Tech stack agent recommends choices with rationale"
    - "All 18 tech categories handled"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "techStack JSONB column in projectData"
      contains: "techStack"
    - path: "lib/langchain/agents/tech-stack-agent.ts"
      provides: "Tech stack recommendation agent"
      contains: "recommendTechStack"
  key_links:
    - from: "tech-stack-agent.ts"
      to: "v2-types.ts"
      via: "import TechStackModel"
      pattern: "TechStackModel"
---

<objective>
Add tech stack recommendation with rationale for each technology choice

Purpose: Enable MCP export of recommended tech stack for Claude Code/Cursor context
Output: TechStackModel with choices, alternatives, and rationale for each category
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-2.0.md
@.planning/phases/09-data-model-depth/09-RESEARCH.md
@lib/db/schema.ts
@lib/db/schema/v2-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add techStack column to projectData table</name>
  <files>lib/db/schema.ts</files>
  <action>
Add the `techStack` JSONB column to the `projectData` table:

```typescript
import type { TechStackModel } from './schema/v2-types';

export const projectData = pgTable('project_data', {
  // ... existing columns ...

  // NEW: Tech stack model (Phase 9.3)
  techStack: jsonb('tech_stack').$type<TechStackModel>(),

  // ... rest of columns ...
});
```

This can be added in the same edit as databaseSchema if doing wave 2 together.
  </action>
  <verify>npx tsc --noEmit lib/db/schema.ts 2>&1 | head -10</verify>
  <done>techStack column added to projectData schema</done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply migration for techStack</name>
  <files>lib/db/migrations/</files>
  <action>
Generate migration for techStack column (can be combined with 9.2 migration):

```sql
ALTER TABLE project_data ADD COLUMN IF NOT EXISTS tech_stack JSONB;
```

Or update the Phase 9 migration to include both columns:
```sql
ALTER TABLE project_data
ADD COLUMN IF NOT EXISTS database_schema JSONB,
ADD COLUMN IF NOT EXISTS tech_stack JSONB;
```

Apply migration:
```bash
npx drizzle-kit push
```
  </action>
  <verify>echo "SELECT column_name FROM information_schema.columns WHERE table_name = 'project_data'" | npx drizzle-kit introspect 2>&1 | grep -i tech</verify>
  <done>Migration created and applied</done>
</task>

<task type="auto">
  <name>Task 3: Create tech stack recommendation agent</name>
  <files>lib/langchain/agents/tech-stack-agent.ts</files>
  <action>
Create a new agent that recommends a tech stack based on project requirements:

```typescript
import { ChatOpenAI } from '@langchain/openai';
import { z } from 'zod';
import type {
  TechStackModel,
  TechChoice,
  TechCategory,
} from '../../db/schema/v2-types';

// Zod schemas for validation
const techAlternativeSchema = z.object({
  name: z.string(),
  whyNot: z.string(),
});

const techChoiceSchema = z.object({
  category: z.enum([
    'frontend', 'backend', 'database', 'auth', 'hosting', 'cache',
    'queue', 'monitoring', 'testing', 'ci-cd', 'container', 'cdn',
    'email', 'payments', 'analytics', 'search', 'storage', 'ai-ml', 'other'
  ]),
  choice: z.string(),
  version: z.string().optional(),
  rationale: z.string(),
  alternatives: z.array(techAlternativeSchema),
  documentation: z.string().optional(),
  license: z.string().optional(),
});

const techStackModelSchema = z.object({
  categories: z.array(techChoiceSchema),
  constraints: z.array(z.string()),
  rationale: z.string(),
  estimatedCost: z.string().optional(),
  scalability: z.string().optional(),
  generatedAt: z.string().optional(),
});

interface TechStackContext {
  projectName: string;
  projectVision: string;
  useCases: Array<{ name: string; description: string }>;
  dataEntities: Array<{ name: string }>;
  constraints?: string[]; // e.g., "Must be open source", "Budget < $100/month"
  preferences?: string[]; // e.g., "Prefer TypeScript", "Team knows React"
}

export async function recommendTechStack(
  context: TechStackContext
): Promise<TechStackModel> {
  const model = new ChatOpenAI({
    model: 'gpt-4o',
    temperature: 0.3, // Slightly creative for tech recommendations
  });

  const prompt = buildTechStackPrompt(context);

  const result = await model.invoke([
    {
      role: 'system',
      content: `You are a senior software architect recommending technology stacks. Consider scalability, team productivity, cost, and ecosystem maturity. Always provide rationale for choices and name alternatives you considered. Output valid JSON only.`,
    },
    {
      role: 'user',
      content: prompt,
    },
  ]);

  const content = result.content as string;
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Failed to extract JSON from tech stack response');
  }

  const parsed = JSON.parse(jsonMatch[0]);
  const validated = techStackModelSchema.parse(parsed);

  return {
    ...validated,
    generatedAt: new Date().toISOString(),
  };
}

function buildTechStackPrompt(context: TechStackContext): string {
  const constraintsSection = context.constraints?.length
    ? `\nConstraints:\n${context.constraints.map(c => `- ${c}`).join('\n')}`
    : '';

  const preferencesSection = context.preferences?.length
    ? `\nTeam Preferences:\n${context.preferences.map(p => `- ${p}`).join('\n')}`
    : '';

  return `
Project: ${context.projectName}
Vision: ${context.projectVision}

Use Cases (${context.useCases.length}):
${context.useCases.slice(0, 5).map(uc => `- ${uc.name}: ${uc.description}`).join('\n')}

Data Entities (${context.dataEntities.length}):
${context.dataEntities.map(e => `- ${e.name}`).join(', ')}
${constraintsSection}
${preferencesSection}

Recommend a modern tech stack. For each category, provide:
1. Your recommended choice with version
2. Why you chose it (rationale)
3. 1-2 alternatives you considered and why you didn't choose them
4. Link to documentation if relevant

Categories to cover:
- frontend: UI framework (React, Vue, Svelte, etc.)
- backend: Server framework (Next.js, Express, FastAPI, etc.)
- database: Primary database (PostgreSQL, MongoDB, etc.)
- auth: Authentication solution (Clerk, Auth.js, Supabase Auth, etc.)
- hosting: Deployment platform (Vercel, AWS, Railway, etc.)
- testing: Test framework (Vitest, Jest, Playwright, etc.)

Optional categories (include if relevant to the project):
- cache, queue, monitoring, ci-cd, container, cdn, email, payments, analytics, search, storage, ai-ml

Output JSON:
{
  "categories": [
    {
      "category": "frontend",
      "choice": "React",
      "version": "19",
      "rationale": "Most popular, huge ecosystem, team familiarity",
      "alternatives": [
        { "name": "Vue", "whyNot": "Smaller ecosystem for enterprise features" }
      ],
      "documentation": "https://react.dev"
    }
  ],
  "constraints": ["Must be TypeScript-compatible"],
  "rationale": "Overall stack rationale...",
  "estimatedCost": "$50-100/month for initial deployment",
  "scalability": "Can scale to 100k users with current architecture"
}
`;
}

// Export for testing
export { techStackModelSchema, techChoiceSchema };
```
  </action>
  <verify>npx tsc --noEmit lib/langchain/agents/tech-stack-agent.ts 2>&1 | head -10</verify>
  <done>Tech stack agent created and compiles</done>
</task>

<task type="auto">
  <name>Task 4: Add tech stack queries</name>
  <files>lib/db/queries/project-data.ts</files>
  <action>
Add queries for tech stack operations:

```typescript
import type { TechStackModel } from '../schema/v2-types';

/**
 * Get tech stack for a project
 */
export async function getTechStack(
  projectId: number
): Promise<TechStackModel | null> {
  const result = await db.query.projectData.findFirst({
    where: eq(projectData.projectId, projectId),
    columns: { techStack: true },
  });
  return result?.techStack ?? null;
}

/**
 * Update tech stack for a project
 */
export async function updateTechStack(
  projectId: number,
  stack: TechStackModel
): Promise<void> {
  await db
    .update(projectData)
    .set({
      techStack: stack,
      updatedAt: new Date(),
    })
    .where(eq(projectData.projectId, projectId));
}

/**
 * Get tech choice for a specific category
 */
export async function getTechChoice(
  projectId: number,
  category: string
): Promise<TechChoice | null> {
  const stack = await getTechStack(projectId);
  if (!stack) return null;
  return stack.categories.find(c => c.category === category) ?? null;
}
```
  </action>
  <verify>npx tsc --noEmit lib/db/queries/project-data.ts 2>&1 | head -10</verify>
  <done>Tech stack queries compile without errors</done>
</task>

<task type="auto">
  <name>Task 5: Create API endpoint for tech stack</name>
  <files>app/api/projects/[id]/tech-stack/route.ts</files>
  <action>
Create API endpoint to get/generate tech stack:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getTechStack, updateTechStack, getProjectData } from '@/lib/db/queries/project-data';
import { recommendTechStack } from '@/lib/langchain/agents/tech-stack-agent';
import { getProject } from '@/lib/db/queries/projects';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const projectId = parseInt(params.id);
    const techStack = await getTechStack(projectId);

    if (!techStack) {
      return NextResponse.json(
        { error: 'Tech stack not generated yet' },
        { status: 404 }
      );
    }

    return NextResponse.json(techStack);
  } catch (error) {
    console.error('Error fetching tech stack:', error);
    return NextResponse.json(
      { error: 'Failed to fetch tech stack' },
      { status: 500 }
    );
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const projectId = parseInt(params.id);
    const project = await getProject(projectId);
    const projectData = await getProjectData(projectId);

    if (!project || !projectData) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    const body = await request.json().catch(() => ({}));

    const techStack = await recommendTechStack({
      projectName: project.name,
      projectVision: project.vision,
      useCases: projectData.useCases || [],
      dataEntities: projectData.dataEntities || [],
      constraints: body.constraints,
      preferences: body.preferences,
    });

    await updateTechStack(projectId, techStack);

    return NextResponse.json(techStack);
  } catch (error) {
    console.error('Error generating tech stack:', error);
    return NextResponse.json(
      { error: 'Failed to generate tech stack' },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>npx tsc --noEmit app/api/projects/[id]/tech-stack/route.ts 2>&1 | head -10</verify>
  <done>Tech stack API endpoint compiles</done>
</task>

</tasks>

<verification>
Run type checking:
```bash
npx tsc --noEmit
```

Test API endpoint:
```bash
# Generate tech stack
curl -X POST http://localhost:3000/api/projects/1/tech-stack \
  -H "Content-Type: application/json" \
  -d '{"preferences": ["TypeScript", "React"]}'

# Get tech stack
curl http://localhost:3000/api/projects/1/tech-stack
```

Manual verification:
1. Create test project
2. POST to generate tech stack
3. Verify all categories have choices with rationale
4. Verify alternatives are provided
</verification>

<success_criteria>
- techStack column exists in project_data table
- Tech stack agent recommends choices for all relevant categories
- Each choice has rationale explaining why it was selected
- Alternatives are provided with "whyNot" explanations
- API endpoint returns valid TechStackModel JSON
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-data-model-depth/09-03-SUMMARY.md`
</output>
