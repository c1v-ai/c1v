---
phase: 09-data-model-depth
plan: 04
type: execute
wave: 3
depends_on: ["09-01"]
files_modified:
  - lib/db/schema.ts
  - lib/langchain/agents/user-stories-agent.ts
  - lib/db/queries/user-stories.ts
  - app/api/projects/[id]/stories/route.ts
  - app/api/projects/[id]/stories/[storyId]/route.ts
autonomous: true

must_haves:
  truths:
    - "user_stories table exists with all required columns"
    - "User stories agent transforms use cases into stories"
    - "API endpoints support CRUD operations"
    - "Stories have status, priority, and acceptance criteria"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "userStories table definition"
      contains: "userStories"
    - path: "lib/langchain/agents/user-stories-agent.ts"
      provides: "User stories generation agent"
      contains: "generateUserStories"
    - path: "app/api/projects/[id]/stories/route.ts"
      provides: "Stories API endpoints"
      contains: "GET"
  key_links:
    - from: "user-stories-agent.ts"
      to: "v2-types.ts"
      via: "import UserStory"
      pattern: "UserStory"
---

<objective>
Create user stories table and agent to transform use cases into trackable backlog items

Purpose: Enable kanban-style story tracking and MCP export for development workflow
Output: user_stories table with CRUD API and story generation from use cases
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-2.0.md
@.planning/phases/09-data-model-depth/09-RESEARCH.md
@lib/db/schema.ts
@lib/db/schema/v2-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create userStories table in schema</name>
  <files>lib/db/schema.ts</files>
  <action>
Add the `userStories` table definition:

```typescript
// User Stories Table (Phase 9.4)
export const userStories = pgTable('user_stories', {
  id: serial('id').primaryKey(),
  projectId: integer('project_id')
    .notNull()
    .references(() => projects.id, { onDelete: 'cascade' }),
  useCaseId: varchar('use_case_id', { length: 50 }), // Links to use case by ID (e.g., "UC-001")

  // Story content
  title: text('title').notNull(),
  description: text('description').notNull(), // "As a [actor], I want [goal], so that [benefit]"
  actor: varchar('actor', { length: 100 }).notNull(),
  epic: varchar('epic', { length: 100 }),

  // Acceptance criteria (JSONB array)
  acceptanceCriteria: jsonb('acceptance_criteria').$type<string[]>().default([]),

  // Tracking
  status: varchar('status', { length: 20 }).notNull().default('backlog'),
  priority: varchar('priority', { length: 20 }).notNull().default('medium'),
  estimatedEffort: varchar('estimated_effort', { length: 20 }),

  // Ordering
  order: integer('order').notNull().default(0),

  // Optional fields
  assignee: varchar('assignee', { length: 100 }),
  labels: jsonb('labels').$type<string[]>().default([]),
  blockedBy: jsonb('blocked_by').$type<number[]>().default([]),

  // Timestamps
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
}, (table) => ({
  projectIdIdx: index('user_stories_project_id_idx').on(table.projectId),
  statusIdx: index('user_stories_status_idx').on(table.status),
  priorityIdx: index('user_stories_priority_idx').on(table.priority),
  useCaseIdIdx: index('user_stories_use_case_id_idx').on(table.useCaseId),
}));

// Add relations
export const userStoriesRelations = relations(userStories, ({ one }) => ({
  project: one(projects, {
    fields: [userStories.projectId],
    references: [projects.id],
  }),
}));

// Update projects relations to include stories
export const projectsRelationsExtended = relations(projects, ({ one, many }) => ({
  // ... existing relations ...
  userStories: many(userStories),
}));

// Types
export type UserStoryRecord = typeof userStories.$inferSelect;
export type NewUserStoryRecord = typeof userStories.$inferInsert;
```

Also add enums for type safety:
```typescript
export enum UserStoryStatus {
  BACKLOG = 'backlog',
  TODO = 'todo',
  IN_PROGRESS = 'in-progress',
  REVIEW = 'review',
  DONE = 'done',
  BLOCKED = 'blocked',
}

export enum UserStoryPriority {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
}

export enum UserStoryEffort {
  XS = 'xs',
  SMALL = 'small',
  MEDIUM = 'medium',
  LARGE = 'large',
  XL = 'xl',
}
```
  </action>
  <verify>npx tsc --noEmit lib/db/schema.ts 2>&1 | head -10</verify>
  <done>userStories table defined in schema</done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply migration for user_stories</name>
  <files>lib/db/migrations/</files>
  <action>
Generate the Drizzle migration:

```bash
npx drizzle-kit generate --name add_user_stories_table
```

Or create manually `lib/db/migrations/20260125_add_user_stories.sql`:
```sql
CREATE TABLE IF NOT EXISTS user_stories (
  id SERIAL PRIMARY KEY,
  project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  use_case_id VARCHAR(50),
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  actor VARCHAR(100) NOT NULL,
  epic VARCHAR(100),
  acceptance_criteria JSONB DEFAULT '[]',
  status VARCHAR(20) NOT NULL DEFAULT 'backlog',
  priority VARCHAR(20) NOT NULL DEFAULT 'medium',
  estimated_effort VARCHAR(20),
  "order" INTEGER NOT NULL DEFAULT 0,
  assignee VARCHAR(100),
  labels JSONB DEFAULT '[]',
  blocked_by JSONB DEFAULT '[]',
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS user_stories_project_id_idx ON user_stories(project_id);
CREATE INDEX IF NOT EXISTS user_stories_status_idx ON user_stories(status);
CREATE INDEX IF NOT EXISTS user_stories_priority_idx ON user_stories(priority);
CREATE INDEX IF NOT EXISTS user_stories_use_case_id_idx ON user_stories(use_case_id);
```

Apply migration:
```bash
npx drizzle-kit push
```
  </action>
  <verify>echo "SELECT table_name FROM information_schema.tables WHERE table_name = 'user_stories'" | npx drizzle-kit introspect 2>&1</verify>
  <done>user_stories table created in database</done>
</task>

<task type="auto">
  <name>Task 3: Create user stories generation agent</name>
  <files>lib/langchain/agents/user-stories-agent.ts</files>
  <action>
Create agent that transforms use cases into user stories:

```typescript
import { ChatOpenAI } from '@langchain/openai';
import { z } from 'zod';
import type { EnhancedUseCase } from '../../db/schema/v2-types';

// Zod schema for generated story (without DB fields)
const generatedStorySchema = z.object({
  useCaseId: z.string().optional(),
  title: z.string(),
  description: z.string(), // "As a [actor], I want [goal], so that [benefit]"
  actor: z.string(),
  epic: z.string().optional(),
  acceptanceCriteria: z.array(z.string()),
  priority: z.enum(['critical', 'high', 'medium', 'low']),
  estimatedEffort: z.enum(['xs', 'small', 'medium', 'large', 'xl']),
});

const generatedStoriesSchema = z.object({
  stories: z.array(generatedStorySchema),
});

export type GeneratedStory = z.infer<typeof generatedStorySchema>;

interface UserStoriesContext {
  projectName: string;
  projectVision: string;
  useCases: EnhancedUseCase[];
  actors: Array<{ name: string; role: string }>;
}

export async function generateUserStories(
  context: UserStoriesContext
): Promise<GeneratedStory[]> {
  const model = new ChatOpenAI({
    model: 'gpt-4o',
    temperature: 0.2,
  });

  const prompt = buildUserStoriesPrompt(context);

  const result = await model.invoke([
    {
      role: 'system',
      content: `You are a product manager creating user stories from use cases. Each use case should generate 1-3 user stories. Use the standard format: "As a [actor], I want [goal], so that [benefit]". Include testable acceptance criteria. Output valid JSON only.`,
    },
    {
      role: 'user',
      content: prompt,
    },
  ]);

  const content = result.content as string;
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Failed to extract JSON from user stories response');
  }

  const parsed = JSON.parse(jsonMatch[0]);
  const validated = generatedStoriesSchema.parse(parsed);

  return validated.stories;
}

function buildUserStoriesPrompt(context: UserStoriesContext): string {
  return `
Project: ${context.projectName}
Vision: ${context.projectVision}

Actors:
${context.actors.map(a => `- ${a.name} (${a.role})`).join('\n')}

Use Cases to transform:
${context.useCases.map(uc => `
Use Case ${uc.id}: ${uc.name}
- Actor: ${uc.actor}
- Description: ${uc.description}
- Trigger: ${uc.trigger || 'Not specified'}
- Outcome: ${uc.outcome || 'Not specified'}
- Acceptance Criteria: ${uc.acceptanceCriteria?.join(', ') || 'Not specified'}
- Priority: ${uc.priority || 'should'}
`).join('\n')}

For each use case, generate 1-3 user stories:
1. Break complex use cases into smaller, implementable stories
2. Use format: "As a [actor], I want [goal], so that [benefit]"
3. Include 2-5 testable acceptance criteria per story
4. Estimate effort: xs (1-2h), small (half day), medium (1 day), large (2-3 days), xl (1 week+)
5. Set priority based on use case priority

Output JSON:
{
  "stories": [
    {
      "useCaseId": "UC-001",
      "title": "User can log in with email",
      "description": "As a registered user, I want to log in with my email and password, so that I can access my account",
      "actor": "User",
      "epic": "Authentication",
      "acceptanceCriteria": [
        "Login form has email and password fields",
        "Error shown for invalid credentials",
        "User redirected to dashboard on success"
      ],
      "priority": "critical",
      "estimatedEffort": "medium"
    }
  ]
}
`;
}

// Helper to transform generated stories for DB insert
export function prepareStoriesForInsert(
  projectId: number,
  stories: GeneratedStory[]
): Array<{
  projectId: number;
  useCaseId: string | null;
  title: string;
  description: string;
  actor: string;
  epic: string | null;
  acceptanceCriteria: string[];
  status: string;
  priority: string;
  estimatedEffort: string | null;
  order: number;
}> {
  return stories.map((story, index) => ({
    projectId,
    useCaseId: story.useCaseId ?? null,
    title: story.title,
    description: story.description,
    actor: story.actor,
    epic: story.epic ?? null,
    acceptanceCriteria: story.acceptanceCriteria,
    status: 'backlog',
    priority: story.priority,
    estimatedEffort: story.estimatedEffort ?? null,
    order: index,
  }));
}

export { generatedStorySchema, generatedStoriesSchema };
```
  </action>
  <verify>npx tsc --noEmit lib/langchain/agents/user-stories-agent.ts 2>&1 | head -10</verify>
  <done>User stories agent created and compiles</done>
</task>

<task type="auto">
  <name>Task 4: Create user stories queries</name>
  <files>lib/db/queries/user-stories.ts</files>
  <action>
Create CRUD queries for user stories:

```typescript
import { eq, and, asc, desc } from 'drizzle-orm';
import { db } from '../client';
import { userStories, UserStoryRecord, NewUserStoryRecord } from '../schema';

/**
 * Get all stories for a project
 */
export async function getProjectStories(
  projectId: number,
  options?: {
    status?: string;
    priority?: string;
    orderBy?: 'order' | 'priority' | 'createdAt';
    orderDir?: 'asc' | 'desc';
  }
): Promise<UserStoryRecord[]> {
  const conditions = [eq(userStories.projectId, projectId)];

  if (options?.status) {
    conditions.push(eq(userStories.status, options.status));
  }
  if (options?.priority) {
    conditions.push(eq(userStories.priority, options.priority));
  }

  const orderColumn = options?.orderBy === 'priority'
    ? userStories.priority
    : options?.orderBy === 'createdAt'
      ? userStories.createdAt
      : userStories.order;

  const orderFn = options?.orderDir === 'desc' ? desc : asc;

  return db.query.userStories.findMany({
    where: and(...conditions),
    orderBy: [orderFn(orderColumn)],
  });
}

/**
 * Get a single story by ID
 */
export async function getStory(storyId: number): Promise<UserStoryRecord | null> {
  const result = await db.query.userStories.findFirst({
    where: eq(userStories.id, storyId),
  });
  return result ?? null;
}

/**
 * Create a new story
 */
export async function createStory(
  data: NewUserStoryRecord
): Promise<UserStoryRecord> {
  const [result] = await db.insert(userStories).values(data).returning();
  return result;
}

/**
 * Create multiple stories (bulk insert)
 */
export async function createStories(
  data: NewUserStoryRecord[]
): Promise<UserStoryRecord[]> {
  if (data.length === 0) return [];
  return db.insert(userStories).values(data).returning();
}

/**
 * Update a story
 */
export async function updateStory(
  storyId: number,
  data: Partial<Omit<UserStoryRecord, 'id' | 'projectId' | 'createdAt'>>
): Promise<UserStoryRecord | null> {
  const [result] = await db
    .update(userStories)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(userStories.id, storyId))
    .returning();
  return result ?? null;
}

/**
 * Update story status (common operation)
 */
export async function updateStoryStatus(
  storyId: number,
  status: string
): Promise<UserStoryRecord | null> {
  return updateStory(storyId, { status });
}

/**
 * Delete a story
 */
export async function deleteStory(storyId: number): Promise<boolean> {
  const result = await db
    .delete(userStories)
    .where(eq(userStories.id, storyId))
    .returning({ id: userStories.id });
  return result.length > 0;
}

/**
 * Reorder stories within a project
 */
export async function reorderStories(
  projectId: number,
  storyOrders: Array<{ id: number; order: number }>
): Promise<void> {
  // Use transaction for atomic reordering
  await db.transaction(async (tx) => {
    for (const { id, order } of storyOrders) {
      await tx
        .update(userStories)
        .set({ order, updatedAt: new Date() })
        .where(and(
          eq(userStories.id, id),
          eq(userStories.projectId, projectId)
        ));
    }
  });
}

/**
 * Get stories by use case ID
 */
export async function getStoriesByUseCase(
  projectId: number,
  useCaseId: string
): Promise<UserStoryRecord[]> {
  return db.query.userStories.findMany({
    where: and(
      eq(userStories.projectId, projectId),
      eq(userStories.useCaseId, useCaseId)
    ),
    orderBy: [asc(userStories.order)],
  });
}

/**
 * Get story counts by status (for dashboard)
 */
export async function getStoryCountsByStatus(
  projectId: number
): Promise<Record<string, number>> {
  const stories = await getProjectStories(projectId);
  return stories.reduce((acc, story) => {
    acc[story.status] = (acc[story.status] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}
```
  </action>
  <verify>npx tsc --noEmit lib/db/queries/user-stories.ts 2>&1 | head -10</verify>
  <done>User stories queries compile without errors</done>
</task>

<task type="auto">
  <name>Task 5: Create stories API endpoints</name>
  <files>app/api/projects/[id]/stories/route.ts</files>
  <action>
Create the stories list/create API:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import {
  getProjectStories,
  createStories,
} from '@/lib/db/queries/user-stories';
import { getProjectData } from '@/lib/db/queries/project-data';
import { getProject } from '@/lib/db/queries/projects';
import {
  generateUserStories,
  prepareStoriesForInsert,
} from '@/lib/langchain/agents/user-stories-agent';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const projectId = parseInt(params.id);
    const searchParams = request.nextUrl.searchParams;

    const stories = await getProjectStories(projectId, {
      status: searchParams.get('status') ?? undefined,
      priority: searchParams.get('priority') ?? undefined,
      orderBy: (searchParams.get('orderBy') as 'order' | 'priority' | 'createdAt') ?? 'order',
      orderDir: (searchParams.get('orderDir') as 'asc' | 'desc') ?? 'asc',
    });

    return NextResponse.json({ stories });
  } catch (error) {
    console.error('Error fetching stories:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stories' },
      { status: 500 }
    );
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const projectId = parseInt(params.id);
    const body = await request.json();

    // If action is "generate", create stories from use cases
    if (body.action === 'generate') {
      const project = await getProject(projectId);
      const projectData = await getProjectData(projectId);

      if (!project || !projectData) {
        return NextResponse.json(
          { error: 'Project not found' },
          { status: 404 }
        );
      }

      if (!projectData.useCases?.length) {
        return NextResponse.json(
          { error: 'No use cases to generate stories from' },
          { status: 400 }
        );
      }

      const generatedStories = await generateUserStories({
        projectName: project.name,
        projectVision: project.vision,
        useCases: projectData.useCases,
        actors: projectData.actors || [],
      });

      const storiesForInsert = prepareStoriesForInsert(projectId, generatedStories);
      const created = await createStories(storiesForInsert);

      return NextResponse.json({
        stories: created,
        generated: generatedStories.length,
      });
    }

    // Otherwise, create a single story manually
    const { title, description, actor, ...rest } = body;

    if (!title || !description || !actor) {
      return NextResponse.json(
        { error: 'title, description, and actor are required' },
        { status: 400 }
      );
    }

    const [created] = await createStories([{
      projectId,
      title,
      description,
      actor,
      useCaseId: rest.useCaseId ?? null,
      epic: rest.epic ?? null,
      acceptanceCriteria: rest.acceptanceCriteria ?? [],
      status: rest.status ?? 'backlog',
      priority: rest.priority ?? 'medium',
      estimatedEffort: rest.estimatedEffort ?? null,
      order: rest.order ?? 0,
    }]);

    return NextResponse.json({ story: created }, { status: 201 });
  } catch (error) {
    console.error('Error creating stories:', error);
    return NextResponse.json(
      { error: 'Failed to create stories' },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>npx tsc --noEmit app/api/projects/[id]/stories/route.ts 2>&1 | head -10</verify>
  <done>Stories list/create API compiles</done>
</task>

<task type="auto">
  <name>Task 6: Create single story API endpoint</name>
  <files>app/api/projects/[id]/stories/[storyId]/route.ts</files>
  <action>
Create the single story GET/PUT/DELETE API:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import {
  getStory,
  updateStory,
  deleteStory,
} from '@/lib/db/queries/user-stories';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string; storyId: string } }
) {
  try {
    const storyId = parseInt(params.storyId);
    const story = await getStory(storyId);

    if (!story) {
      return NextResponse.json(
        { error: 'Story not found' },
        { status: 404 }
      );
    }

    // Verify story belongs to project
    const projectId = parseInt(params.id);
    if (story.projectId !== projectId) {
      return NextResponse.json(
        { error: 'Story not found in this project' },
        { status: 404 }
      );
    }

    return NextResponse.json({ story });
  } catch (error) {
    console.error('Error fetching story:', error);
    return NextResponse.json(
      { error: 'Failed to fetch story' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string; storyId: string } }
) {
  try {
    const storyId = parseInt(params.storyId);
    const projectId = parseInt(params.id);
    const body = await request.json();

    // Verify story exists and belongs to project
    const existing = await getStory(storyId);
    if (!existing || existing.projectId !== projectId) {
      return NextResponse.json(
        { error: 'Story not found' },
        { status: 404 }
      );
    }

    // Update allowed fields
    const updateData: Record<string, unknown> = {};
    const allowedFields = [
      'title', 'description', 'actor', 'epic', 'acceptanceCriteria',
      'status', 'priority', 'estimatedEffort', 'order', 'assignee',
      'labels', 'blockedBy'
    ];

    for (const field of allowedFields) {
      if (body[field] !== undefined) {
        updateData[field] = body[field];
      }
    }

    const updated = await updateStory(storyId, updateData);

    return NextResponse.json({ story: updated });
  } catch (error) {
    console.error('Error updating story:', error);
    return NextResponse.json(
      { error: 'Failed to update story' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string; storyId: string } }
) {
  try {
    const storyId = parseInt(params.storyId);
    const projectId = parseInt(params.id);

    // Verify story exists and belongs to project
    const existing = await getStory(storyId);
    if (!existing || existing.projectId !== projectId) {
      return NextResponse.json(
        { error: 'Story not found' },
        { status: 404 }
      );
    }

    await deleteStory(storyId);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting story:', error);
    return NextResponse.json(
      { error: 'Failed to delete story' },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>npx tsc --noEmit app/api/projects/[id]/stories/[storyId]/route.ts 2>&1 | head -10</verify>
  <done>Single story API compiles</done>
</task>

</tasks>

<verification>
Run type checking:
```bash
npx tsc --noEmit
```

Check migration status:
```bash
npx drizzle-kit push --dry-run
```

Test API endpoints:
```bash
# Generate stories from use cases
curl -X POST http://localhost:3000/api/projects/1/stories \
  -H "Content-Type: application/json" \
  -d '{"action": "generate"}'

# Get all stories
curl http://localhost:3000/api/projects/1/stories

# Update story status
curl -X PUT http://localhost:3000/api/projects/1/stories/1 \
  -H "Content-Type: application/json" \
  -d '{"status": "in-progress"}'
```

Manual verification:
1. Generate stories from project with use cases
2. Verify stories have proper format (As a..., I want..., so that...)
3. Update story status via API
4. Verify order field works for sorting
</verification>

<success_criteria>
- user_stories table exists with all columns
- User stories agent generates stories from use cases
- Stories follow "As a... I want... so that..." format
- Acceptance criteria populated for each story
- Priority and effort estimates set
- API supports CRUD operations
- Status updates work (for kanban in Phase 13)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-data-model-depth/09-04-SUMMARY.md`
</output>
