---
phase: 09-data-model-depth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/langchain/schemas.ts
  - lib/langchain/agents/extraction-agent.ts
  - lib/db/schema/v2-validators.ts
autonomous: true

must_haves:
  truths:
    - "Enhanced use case schema includes trigger, outcome, mainFlow"
    - "Extraction agent extracts enhanced use case fields"
    - "Zod validation passes for enhanced use cases"
  artifacts:
    - path: "lib/langchain/schemas.ts"
      provides: "Extended useCaseSchema with enhanced fields"
      contains: "mainFlow"
    - path: "lib/langchain/agents/extraction-agent.ts"
      provides: "Enhanced extraction prompt"
      contains: "acceptanceCriteria"
  key_links:
    - from: "extraction-agent.ts"
      to: "schemas.ts"
      via: "import useCaseSchema"
      pattern: "from.*schemas"
---

<objective>
Enhance use case data model with trigger, outcome, flows, and acceptance criteria

Purpose: Match Epic.dev's use case detail level for MCP export
Output: Use cases extracted with mainFlow, alternativeFlows, acceptanceCriteria
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-2.0.md
@.planning/phases/09-data-model-depth/09-RESEARCH.md
@lib/langchain/schemas.ts
@lib/langchain/agents/extraction-agent.ts
@lib/db/schema/v2-types.ts
@lib/db/schema/v2-validators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useCaseSchema in schemas.ts</name>
  <files>lib/langchain/schemas.ts</files>
  <action>
Update the `useCaseSchema` to include all enhanced fields from v2-types.ts:

```typescript
import { z } from 'zod';

// Flow step for use case main flow
export const flowStepSchema = z.object({
  stepNumber: z.number(),
  actor: z.string(),
  action: z.string(),
  systemResponse: z.string().optional(),
});

// Alternative flow (exception path)
export const alternativeFlowSchema = z.object({
  id: z.string(),
  name: z.string(),
  branchPoint: z.number(),
  condition: z.string(),
  steps: z.array(flowStepSchema),
  rejoinsAt: z.number().optional(),
});

// Enhanced use case schema (replaces existing)
export const useCaseSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  actor: z.string(),
  // Enhanced fields (all optional for backward compatibility)
  trigger: z.string().optional(),
  outcome: z.string().optional(),
  preconditions: z.array(z.string()).optional().default([]),
  postconditions: z.array(z.string()).optional().default([]),
  mainFlow: z.array(flowStepSchema).optional().default([]),
  alternativeFlows: z.array(alternativeFlowSchema).optional().default([]),
  acceptanceCriteria: z.array(z.string()).optional().default([]),
  priority: z.enum(['must', 'should', 'could', 'wont']).optional().default('should'),
  status: z.enum(['draft', 'validated']).optional().default('draft'),
});

export type UseCase = z.infer<typeof useCaseSchema>;
export type FlowStep = z.infer<typeof flowStepSchema>;
export type AlternativeFlow = z.infer<typeof alternativeFlowSchema>;
```

Also add the `isEnhancedUseCase()` type guard:
```typescript
export function isEnhancedUseCase(useCase: unknown): useCase is UseCase {
  return useCaseSchema.safeParse(useCase).success;
}
```
  </action>
  <verify>npx tsc --noEmit lib/langchain/schemas.ts 2>&1 | head -20</verify>
  <done>Enhanced useCaseSchema compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Update extraction prompt for enhanced use cases</name>
  <files>lib/langchain/agents/extraction-agent.ts</files>
  <action>
Update the extraction prompt to request enhanced use case fields. Find the prompt template in `extractProjectData()` and add instructions for:

1. **trigger** - What event or action initiates this use case
2. **outcome** - The end state when the use case completes successfully
3. **mainFlow** - Numbered steps: actor, action, system response
4. **acceptanceCriteria** - Testable conditions for "done"
5. **priority** - MoSCoW priority (must/should/could/wont)

Example prompt addition:
```typescript
const enhancedUseCaseInstructions = `
For each use case, extract:
- id: Unique identifier (UC-001, UC-002, etc.)
- name: Brief name
- description: Full description
- actor: Primary actor
- trigger: What initiates this use case (e.g., "User clicks login button")
- outcome: Expected end state (e.g., "User is authenticated and redirected to dashboard")
- preconditions: What must be true before this can start
- postconditions: What will be true after completion
- mainFlow: Array of steps, each with:
  - stepNumber (1, 2, 3...)
  - actor (who performs this step)
  - action (what they do)
  - systemResponse (optional - what the system does in response)
- acceptanceCriteria: Testable conditions (e.g., "User sees welcome message")
- priority: "must" for critical, "should" for important, "could" for nice-to-have
`;
```

Update the JSON schema example in the prompt to show the enhanced structure.
  </action>
  <verify>grep -A5 "mainFlow\|acceptanceCriteria" lib/langchain/agents/extraction-agent.ts</verify>
  <done>Extraction prompt includes enhanced use case fields</done>
</task>

<task type="auto">
  <name>Task 3: Update extractionSchema to use enhanced useCaseSchema</name>
  <files>lib/langchain/agents/extraction-agent.ts</files>
  <action>
Ensure the `extractionSchema` (or `ExtractionResult` type) uses the enhanced useCaseSchema:

```typescript
import { useCaseSchema, flowStepSchema, alternativeFlowSchema } from '../schemas';

// Update the extraction result schema
export const extractionSchema = z.object({
  actors: z.array(actorSchema),
  useCases: z.array(useCaseSchema), // Now uses enhanced schema
  systemBoundaries: systemBoundariesSchema,
  dataEntities: z.array(dataEntitySchema),
});
```

Also update the `mergeExtractionData()` function to properly merge enhanced use case fields:
```typescript
function mergeUseCases(existing: UseCase[], newData: UseCase[]): UseCase[] {
  const merged = [...existing];
  for (const newUC of newData) {
    const existingIndex = merged.findIndex(uc => uc.id === newUC.id);
    if (existingIndex >= 0) {
      // Merge: prefer new data for enhanced fields, keep existing if new is empty
      merged[existingIndex] = {
        ...merged[existingIndex],
        ...newUC,
        mainFlow: newUC.mainFlow?.length ? newUC.mainFlow : merged[existingIndex].mainFlow,
        acceptanceCriteria: newUC.acceptanceCriteria?.length
          ? newUC.acceptanceCriteria
          : merged[existingIndex].acceptanceCriteria,
      };
    } else {
      merged.push(newUC);
    }
  }
  return merged;
}
```
  </action>
  <verify>npx tsc --noEmit lib/langchain/agents/extraction-agent.ts 2>&1 | head -20</verify>
  <done>Extraction agent compiles and uses enhanced useCaseSchema</done>
</task>

<task type="auto">
  <name>Task 4: Add enhanced use case validators</name>
  <files>lib/db/schema/v2-validators.ts</files>
  <action>
Add or update validators for enhanced use cases. The file may already have `enhancedUseCaseSchema` - verify and complete if needed:

```typescript
import { z } from 'zod';

// Re-export from schemas for consistency
export {
  useCaseSchema as enhancedUseCaseSchema,
  flowStepSchema,
  alternativeFlowSchema,
} from '../../langchain/schemas';

// Input validator for creating use cases via API
export const useCaseInputSchema = z.object({
  name: z.string().min(1).max(200),
  description: z.string().min(1).max(2000),
  actor: z.string().min(1).max(100),
  trigger: z.string().max(500).optional(),
  outcome: z.string().max(500).optional(),
  priority: z.enum(['must', 'should', 'could', 'wont']).optional(),
});

// Update validator for modifying use cases
export const useCaseUpdateSchema = useCaseInputSchema.partial();
```
  </action>
  <verify>npx tsc --noEmit lib/db/schema/v2-validators.ts 2>&1 | head -20</verify>
  <done>Enhanced use case validators compile without errors</done>
</task>

<task type="auto">
  <name>Task 5: Test enhanced extraction with sample data</name>
  <files>lib/langchain/agents/__tests__/extraction-agent.test.ts</files>
  <action>
Add or update tests for enhanced use case extraction:

```typescript
describe('extractProjectData - Enhanced Use Cases', () => {
  it('should extract use case with mainFlow', async () => {
    const conversation = [
      'User: The system allows users to log in',
      'Assistant: Can you describe the login flow step by step?',
      'User: First the user enters credentials, then clicks submit, then sees dashboard',
    ];

    const result = await extractProjectData(
      conversation,
      'Test Project',
      'A login system'
    );

    expect(result.useCases).toHaveLength(1);
    expect(result.useCases[0].mainFlow).toBeDefined();
    expect(result.useCases[0].mainFlow.length).toBeGreaterThan(0);
  });

  it('should extract acceptance criteria', async () => {
    const conversation = [
      'User: Login is successful when user sees welcome message and their name',
    ];

    const result = await extractProjectData(
      conversation,
      'Test Project',
      'A login system'
    );

    expect(result.useCases[0].acceptanceCriteria).toBeDefined();
    expect(result.useCases[0].acceptanceCriteria.length).toBeGreaterThan(0);
  });
});
```

Note: These tests require OPENAI_API_KEY. Mark as integration tests if needed.
  </action>
  <verify>npm test -- --testPathPattern="extraction-agent" 2>&1 | tail -20</verify>
  <done>Enhanced extraction tests pass or are marked as integration tests</done>
</task>

</tasks>

<verification>
Run type checking:
```bash
npx tsc --noEmit
```

Run related tests:
```bash
npm test -- --testPathPattern="extraction|schemas"
```

Manual verification:
1. Import useCaseSchema in a REPL or test file
2. Parse a sample enhanced use case object
3. Verify all fields are accessible with proper types
</verification>

<success_criteria>
- useCaseSchema includes trigger, outcome, mainFlow, acceptanceCriteria, priority
- Extraction agent prompt requests enhanced fields
- TypeScript compiles without errors
- Existing tests still pass (no regressions)
- Enhanced use cases can be extracted from conversations
</success_criteria>

<output>
After completion, create `.planning/phases/09-data-model-depth/09-01-SUMMARY.md`
</output>
