---
phase: 09-data-model-depth
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - lib/db/schema.ts
  - lib/langchain/agents/schema-extraction-agent.ts
  - lib/db/queries/project-data.ts
autonomous: true

must_haves:
  truths:
    - "databaseSchema column exists in project_data table"
    - "Schema extraction agent generates valid DatabaseSchemaModel"
    - "Field types, relationships, indexes populated from entities"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "databaseSchema JSONB column in projectData"
      contains: "databaseSchema"
    - path: "lib/langchain/agents/schema-extraction-agent.ts"
      provides: "Schema extraction agent"
      contains: "extractDatabaseSchema"
  key_links:
    - from: "schema-extraction-agent.ts"
      to: "v2-types.ts"
      via: "import DatabaseSchemaModel"
      pattern: "DatabaseSchemaModel"
---

<objective>
Add full database schema model with fields, types, relationships, and constraints

Purpose: Enable MCP export of complete database schema for code generation
Output: DatabaseSchemaModel extracted from project entities with full field definitions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-2.0.md
@.planning/phases/09-data-model-depth/09-RESEARCH.md
@lib/db/schema.ts
@lib/db/schema/v2-types.ts
@lib/langchain/agents/extraction-agent.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add databaseSchema column to projectData table</name>
  <files>lib/db/schema.ts</files>
  <action>
Add the `databaseSchema` JSONB column to the `projectData` table:

```typescript
import type { DatabaseSchemaModel } from './schema/v2-types';

export const projectData = pgTable('project_data', {
  id: serial('id').primaryKey(),
  projectId: integer('project_id')
    .notNull()
    .references(() => projects.id, { onDelete: 'cascade' })
    .unique(),

  // Existing extracted data
  actors: jsonb('actors'),
  useCases: jsonb('use_cases'),
  systemBoundaries: jsonb('system_boundaries'),
  dataEntities: jsonb('data_entities'),

  // NEW: Full database schema model (Phase 9.2)
  databaseSchema: jsonb('database_schema').$type<DatabaseSchemaModel>(),

  // Existing fields
  intakeState: jsonb('intake_state'),
  completeness: integer('completeness').default(0),
  lastExtractedAt: timestamp('last_extracted_at'),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});
```

Update the ProjectData type export:
```typescript
export type ProjectData = typeof projectData.$inferSelect;
export type NewProjectData = typeof projectData.$inferInsert;
```
  </action>
  <verify>npx tsc --noEmit lib/db/schema.ts 2>&1 | head -10</verify>
  <done>databaseSchema column added to projectData schema</done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply migration</name>
  <files>lib/db/migrations/</files>
  <action>
Generate the Drizzle migration for the new column:

```bash
npx drizzle-kit generate --name add_database_schema_column
```

Or create manually if drizzle-kit isn't configured:
Create file `lib/db/migrations/20260125_add_database_schema.sql`:
```sql
ALTER TABLE project_data ADD COLUMN IF NOT EXISTS database_schema JSONB;
```

Apply the migration:
```bash
npx drizzle-kit push
```

Or using the migration runner if available:
```bash
npm run db:migrate
```
  </action>
  <verify>echo "SELECT column_name FROM information_schema.columns WHERE table_name = 'project_data'" | npx drizzle-kit introspect 2>&1 | grep -i database</verify>
  <done>Migration created and applied (or ready to apply)</done>
</task>

<task type="auto">
  <name>Task 3: Create schema extraction agent</name>
  <files>lib/langchain/agents/schema-extraction-agent.ts</files>
  <action>
Create a new extraction agent that converts dataEntities into full DatabaseSchemaModel:

```typescript
import { ChatOpenAI } from '@langchain/openai';
import { z } from 'zod';
import type {
  DatabaseSchemaModel,
  DatabaseEntity,
  DatabaseField,
  DatabaseRelationship,
  DataEntity,
} from '../../db/schema/v2-types';

// Zod schema for validation
const databaseFieldSchema = z.object({
  name: z.string(),
  type: z.string(),
  nullable: z.boolean(),
  defaultValue: z.string().optional(),
  constraints: z.array(z.string()),
  description: z.string().optional(),
});

const databaseRelationshipSchema = z.object({
  name: z.string().optional(),
  type: z.enum(['one-to-one', 'one-to-many', 'many-to-many']),
  targetEntity: z.string(),
  foreignKey: z.string(),
  targetKey: z.string().optional(),
  onDelete: z.enum(['CASCADE', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'NO ACTION']).optional(),
  onUpdate: z.enum(['CASCADE', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'NO ACTION']).optional(),
});

const databaseEntitySchema = z.object({
  name: z.string(),
  description: z.string(),
  tableName: z.string().optional(),
  fields: z.array(databaseFieldSchema),
  relationships: z.array(databaseRelationshipSchema),
  indexes: z.array(z.object({
    name: z.string(),
    columns: z.array(z.string()),
    unique: z.boolean().optional(),
    type: z.enum(['btree', 'hash', 'gin', 'gist', 'brin']).optional(),
  })),
  constraints: z.array(z.string()).optional(),
});

const databaseSchemaModelSchema = z.object({
  entities: z.array(databaseEntitySchema),
  enums: z.array(z.object({
    name: z.string(),
    values: z.array(z.string()),
    description: z.string().optional(),
  })).optional(),
  version: z.string().optional(),
  generatedAt: z.string().optional(),
});

interface SchemaExtractionContext {
  projectName: string;
  projectVision: string;
  dataEntities: DataEntity[];
  useCases?: Array<{ name: string; description: string }>;
}

export async function extractDatabaseSchema(
  context: SchemaExtractionContext
): Promise<DatabaseSchemaModel> {
  const model = new ChatOpenAI({
    model: 'gpt-4o',
    temperature: 0,
  });

  const prompt = buildSchemaExtractionPrompt(context);

  const result = await model.invoke([
    {
      role: 'system',
      content: `You are a database architect. Given entity names and their relationships, generate a complete PostgreSQL database schema with proper field types, constraints, indexes, and relationships. Output valid JSON only.`,
    },
    {
      role: 'user',
      content: prompt,
    },
  ]);

  const content = result.content as string;
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Failed to extract JSON from schema response');
  }

  const parsed = JSON.parse(jsonMatch[0]);
  const validated = databaseSchemaModelSchema.parse(parsed);

  return {
    ...validated,
    generatedAt: new Date().toISOString(),
  };
}

function buildSchemaExtractionPrompt(context: SchemaExtractionContext): string {
  return `
Project: ${context.projectName}
Vision: ${context.projectVision}

Entities to model:
${context.dataEntities.map(e => `
- ${e.name}
  Attributes: ${e.attributes.join(', ')}
  Relationships: ${e.relationships.join(', ')}
`).join('\n')}

Generate a complete database schema as JSON with:

1. For each entity, create fields with:
   - name (snake_case)
   - type (uuid, text, integer, timestamp, boolean, jsonb, etc.)
   - nullable (true/false)
   - constraints (PRIMARY KEY, UNIQUE, NOT NULL, etc.)
   - description

2. Add standard fields to all entities:
   - id (uuid, primary key)
   - created_at (timestamp, not null, default now)
   - updated_at (timestamp, not null, default now)

3. For relationships, specify:
   - type (one-to-one, one-to-many, many-to-many)
   - foreignKey column name
   - targetEntity name
   - onDelete action (CASCADE, SET NULL, RESTRICT)

4. Add appropriate indexes:
   - Primary keys (automatic)
   - Foreign keys
   - Frequently queried columns

5. Define any enums needed (e.g., status values)

Output JSON matching this structure:
{
  "entities": [
    {
      "name": "EntityName",
      "description": "What this entity represents",
      "tableName": "entity_names",
      "fields": [...],
      "relationships": [...],
      "indexes": [...]
    }
  ],
  "enums": [
    { "name": "StatusEnum", "values": ["active", "inactive"], "description": "..." }
  ]
}
`;
}

export { databaseSchemaModelSchema };
```
  </action>
  <verify>npx tsc --noEmit lib/langchain/agents/schema-extraction-agent.ts 2>&1 | head -10</verify>
  <done>Schema extraction agent created and compiles</done>
</task>

<task type="auto">
  <name>Task 4: Add database schema queries</name>
  <files>lib/db/queries/project-data.ts</files>
  <action>
Create or update queries file for project data operations:

```typescript
import { eq } from 'drizzle-orm';
import { db } from '../client';
import { projectData } from '../schema';
import type { DatabaseSchemaModel } from '../schema/v2-types';

/**
 * Get database schema for a project
 */
export async function getDatabaseSchema(
  projectId: number
): Promise<DatabaseSchemaModel | null> {
  const result = await db.query.projectData.findFirst({
    where: eq(projectData.projectId, projectId),
    columns: { databaseSchema: true },
  });
  return result?.databaseSchema ?? null;
}

/**
 * Update database schema for a project
 */
export async function updateDatabaseSchema(
  projectId: number,
  schema: DatabaseSchemaModel
): Promise<void> {
  await db
    .update(projectData)
    .set({
      databaseSchema: schema,
      updatedAt: new Date(),
    })
    .where(eq(projectData.projectId, projectId));
}

/**
 * Get project data with all extracted fields
 */
export async function getProjectData(projectId: number) {
  return db.query.projectData.findFirst({
    where: eq(projectData.projectId, projectId),
  });
}

/**
 * Create initial project data record
 */
export async function createProjectData(projectId: number) {
  return db.insert(projectData).values({
    projectId,
    actors: [],
    useCases: [],
    systemBoundaries: { internal: [], external: [] },
    dataEntities: [],
    databaseSchema: null,
    completeness: 0,
  }).returning();
}
```
  </action>
  <verify>npx tsc --noEmit lib/db/queries/project-data.ts 2>&1 | head -10</verify>
  <done>Database schema queries compile without errors</done>
</task>

<task type="auto">
  <name>Task 5: Integrate schema extraction into extraction flow</name>
  <files>lib/langchain/graphs/nodes/extract-data.ts</files>
  <action>
Update the extract-data node to call the schema extraction agent after dataEntities are extracted:

```typescript
import { extractDatabaseSchema } from '../../agents/schema-extraction-agent';
import { updateDatabaseSchema } from '../../../db/queries/project-data';

// Inside the extractData node function, after main extraction:
async function postProcessExtraction(
  state: IntakeState,
  extractionResult: ExtractionResult
) {
  // If we have data entities, generate full database schema
  if (extractionResult.dataEntities.length > 0) {
    try {
      const schemaContext = {
        projectName: state.projectName,
        projectVision: state.projectVision,
        dataEntities: extractionResult.dataEntities,
        useCases: extractionResult.useCases,
      };

      const databaseSchema = await extractDatabaseSchema(schemaContext);

      // Persist to database
      await updateDatabaseSchema(state.projectId, databaseSchema);

      // Optionally attach to state for immediate use
      return {
        ...extractionResult,
        databaseSchema,
      };
    } catch (error) {
      console.error('Schema extraction failed:', error);
      // Continue without schema - non-blocking
    }
  }

  return extractionResult;
}
```

Note: Only call schema extraction when dataEntities have meaningful content (at least 2 entities).
  </action>
  <verify>npx tsc --noEmit lib/langchain/graphs/nodes/extract-data.ts 2>&1 | head -10</verify>
  <done>Schema extraction integrated into extraction flow</done>
</task>

</tasks>

<verification>
Run type checking:
```bash
npx tsc --noEmit
```

Check migration status:
```bash
npx drizzle-kit push --dry-run
```

Manual verification:
1. Create a test project with entities
2. Trigger extraction
3. Query projectData.databaseSchema
4. Verify schema has fields, types, relationships
</verification>

<success_criteria>
- databaseSchema column exists in project_data table
- Schema extraction agent generates valid DatabaseSchemaModel
- Field types inferred correctly (uuid, text, timestamp, etc.)
- Relationships have proper foreign keys and onDelete actions
- Indexes created for foreign keys and common query columns
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-data-model-depth/09-02-SUMMARY.md`
</output>
