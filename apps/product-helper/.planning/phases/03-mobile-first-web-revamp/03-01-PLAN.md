---
phase: 03-mobile-first-web-revamp
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/layout.tsx
  - app/globals.css
  - components/theme/theme-provider.tsx
  - components/theme/mode-toggle.tsx
  - app/(dashboard)/layout.tsx
autonomous: true
subsystem: ui
agent: ui-ux-engineer

must_haves:
  truths:
    - "User can toggle between light, dark, and system themes"
    - "Theme persists across page refresh and browser sessions"
    - "System preference is detected and respected by default"
    - "No flash of incorrect theme on page load"
  artifacts:
    - path: "components/theme/theme-provider.tsx"
      provides: "Client-side theme provider wrapping app"
      exports: ["ThemeProvider"]
    - path: "components/theme/mode-toggle.tsx"
      provides: "Theme toggle dropdown UI component"
      exports: ["ModeToggle"]
    - path: "app/layout.tsx"
      provides: "Root layout with ThemeProvider integration"
      contains: "ThemeProvider"
  key_links:
    - from: "app/layout.tsx"
      to: "components/theme/theme-provider.tsx"
      via: "ThemeProvider wrapping children"
      pattern: "<ThemeProvider"
    - from: "app/(dashboard)/layout.tsx"
      to: "components/theme/mode-toggle.tsx"
      via: "ModeToggle in header"
      pattern: "<ModeToggle"
---

<objective>
Implement light/dark mode with system preference detection using next-themes.

Purpose: Enable users to switch between light and dark themes, respecting their OS preference by default. This is foundational for the mobile-first revamp as it affects all UI components.

Output:
- ThemeProvider component wrapping the app
- ModeToggle component in the header
- Dark mode CSS already exists in theme.css and globals.css (just need runtime switching)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-1.1.md
@.planning/STATE.md
@.planning/phases/03-mobile-first-web-revamp/03-RESEARCH.md

# Existing files to modify
@app/layout.tsx
@app/globals.css
@app/theme.css
@app/(dashboard)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install next-themes and create ThemeProvider</name>
  <files>
    components/theme/theme-provider.tsx
    package.json
  </files>
  <action>
1. Install next-themes: `npm install next-themes`

2. Create `components/theme/theme-provider.tsx`:
```typescript
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
```

This wrapper is needed because next-themes requires "use client" and we want to keep the root layout as a server component where possible.
  </action>
  <verify>
    - File exists at components/theme/theme-provider.tsx
    - next-themes is in package.json dependencies
    - TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>ThemeProvider wrapper component created and exports correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create ModeToggle component</name>
  <files>
    components/theme/mode-toggle.tsx
  </files>
  <action>
Create `components/theme/mode-toggle.tsx` following shadcn/ui pattern:

```typescript
"use client"

import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { useEffect, useState } from "react"

export function ModeToggle() {
  const { setTheme } = useTheme()
  const [mounted, setMounted] = useState(false)

  // Avoid hydration mismatch by only rendering after mount
  useEffect(() => setMounted(true), [])

  if (!mounted) {
    return (
      <Button variant="outline" size="icon" className="h-9 w-9">
        <span className="h-[1.2rem] w-[1.2rem]" />
        <span className="sr-only">Toggle theme</span>
      </Button>
    )
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon" className="h-9 w-9">
          <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
```

IMPORTANT: Use mounted state pattern to prevent hydration mismatch. The placeholder maintains layout while waiting for client-side hydration.
  </action>
  <verify>
    - File exists at components/theme/mode-toggle.tsx
    - Component uses `useTheme` from next-themes
    - Has mounted state to prevent hydration errors
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>ModeToggle component renders theme switcher dropdown with light/dark/system options</done>
</task>

<task type="auto">
  <name>Task 3: Integrate ThemeProvider in root layout and ModeToggle in header</name>
  <files>
    app/layout.tsx
    app/(dashboard)/layout.tsx
  </files>
  <action>
1. Update `app/layout.tsx`:
   - Import ThemeProvider from components/theme/theme-provider
   - Wrap children with ThemeProvider INSIDE SWRConfig
   - Configure: attribute="class", defaultTheme="system", enableSystem, disableTransitionOnChange
   - Keep suppressHydrationWarning on html tag (already present)
   - Remove hardcoded `data-theme="light"` from html tag

```typescript
// Add import
import { ThemeProvider } from '@/components/theme/theme-provider';

// In the return, wrap children:
<ThemeProvider
  attribute="class"
  defaultTheme="system"
  enableSystem
  disableTransitionOnChange
>
  {children}
</ThemeProvider>
```

2. Update `app/(dashboard)/layout.tsx`:
   - Import ModeToggle from components/theme/mode-toggle
   - Add ModeToggle to the header, before the UserMenu in the flex container
   - Place it in the `<div className="flex items-center space-x-4">` section

```typescript
// Add import
import { ModeToggle } from '@/components/theme/mode-toggle';

// In Header component, add before UserMenu:
<div className="flex items-center space-x-4">
  <ModeToggle />
  <Suspense fallback={<div className="h-9" />}>
    <UserMenu />
  </Suspense>
</div>
```
  </action>
  <verify>
    - `npm run dev` starts without errors
    - Visit http://localhost:3000
    - Theme toggle icon visible in header
    - Clicking toggle shows Light/Dark/System options
    - Selecting Dark adds `.dark` class to html element
    - Selecting Light removes `.dark` class
    - Selecting System follows OS preference
    - Refresh page - theme persists (check localStorage for "theme" key)
    - No console hydration warnings
  </verify>
  <done>
    - Theme toggle appears in header
    - Clicking Light/Dark/System changes theme immediately
    - Theme persists across page refresh
    - System preference is detected on first visit
    - No flash of wrong theme on load
  </done>
</task>

</tasks>

<verification>
1. Visual verification:
   - Toggle shows sun icon in light mode, moon in dark mode
   - All UI elements adapt to theme (text, backgrounds, borders)
   - No flicker or flash on page load

2. Functional verification:
   - Open DevTools > Application > Local Storage
   - Check `theme` key updates when toggling
   - Clear localStorage, reload - should follow system preference

3. Code verification:
   - `npx tsc --noEmit` passes
   - `npm run build` succeeds
</verification>

<success_criteria>
- next-themes installed and configured
- ThemeProvider wraps the app at root level
- ModeToggle visible and functional in dashboard header
- Theme persists in localStorage
- System preference detection works
- No hydration errors in console
- Dark mode colors from theme.css and globals.css are applied when .dark class is present
</success_criteria>

<output>
After completion, create `.planning/phases/03-mobile-first-web-revamp/03-01-SUMMARY.md`
</output>
